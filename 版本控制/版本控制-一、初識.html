<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/static/css/typo.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/reset_typo.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
        <link rel="shortcut icon" href="/static/images/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/static/images/favicon.ico" type="image/x-icon">
        <title>一、版本控制初識 - Wiki | Small Cpp</title>
        <meta name="keywords" content=""/>
        <meta name="description" content=""/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="container" class="typo">
            
    <div id="header">
        <div id="post-nav">
            
            <a href="/">Home</a> » <a href="/#版本控制">版本控制</a> » 一、版本控制初識
            
        </div>
    </div>
    <div class="clearfix"></div>
    <div id="content">
        <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">集中式版本控制系统</a></li>
<li><a href="#_2">分布式版本控制</a></li>
</ul>
</div>
<p>版本控制, 這個自己其實一直也在用, 本地的是用 svn, 遠程用的是 github, 但是一直沒怎麼深入, 這次打算系統的好好學一下這方面知識.</p>
<p>版本控制的發展歷史:</p>
<ul>
<li>本地版本控制</li>
<li>集中版本控制,</li>
<li>分布式版本控制</li>
</ul>
<p>本地版本控制, 這個很好理解, 後面兩個階段需要稍微解釋下.</p>
<hr />
<h1 id="_1">集中式版本控制系统</h1>
<p>集中式版本控制系统, 版本库是集中存放在中央服务器的, 而干活的时候, 用的都是自己的电脑, 所以要先从中央服务器取得最新的版本, 然后开始干活, 干完活了, 再把自己的活推送给中央服务器, 中央服务器就好比是一个图书馆, 你要改一本书, 必须先从图书馆借出来, 然后回到家自己改, 改完了, 再放回图书馆.</p>
<p>集中式的版本控制系統其實有三大重點, 即<strong>同步</strong>、<strong>追溯</strong>、以及<strong>檔案的備份</strong>.</p>
<p>同步是為了讓所有開發者間對檔案所做的變更都能夠同步, 最終得到相同的檔案內容.</p>
<p>而追溯, 則是能夠回到受控檔案在變化歷史中的任何一個版本, 並且明白每個版本間變化的原因、以及究竟做了什麼變動.</p>
<p>至於檔案的備份, 無庸置疑的, 就是讓所有的受控檔案集中保管於檔案庫中, 做為備份也利於備份, 不但能取得最新的版本, 也能夠取出任意時間點上的版本.</p>
<p>所以說, 從集中式版本控制系統的設計觀點來看, 它主要是要維持開發者之間保持同步的狀態, 若是依保持同步的手段再細分, 又能衍生出兩種模式, 一種是<strong>鎖定模式</strong>, 而另一種則是<strong>合併模式</strong>.</p>
<p>在鎖定模式下, 當開發者想要修改某檔案、簽出該檔案後, 該檔案便會進入鎖定狀態, 其他開發成員便無法加以修改, 直到簽出者將該檔簽回為止, 對於維持同步來說, 這當然是一個十分保險的作法, 因為永遠不會有兩個或以上的開發者同時修改同一個檔案, 只是, 這種方法造成了開發者對於檔案修改的互斥效應, 使得開發效率受到影響.</p>
<p>因此, 許多版本控制系統採用合併模式, 在合併模式下, 允許多位開發者同時針對同一檔案進行修改, 當他們分別將檔案提交回集中的檔案庫時, 若發生衝突的情況, 便會自動進行合併, 而若自動合併失敗, 再要求人工進行衝突的調解. 不過即使如此, 最終的目的, 還是試圖要維持諸開發者間的同步, 畢竟, 版本控制的結果在集中式檔案庫中是唯一的, 也是每位開發者都需與此結果保持一致的.</p>
<p>再來看看它的<strong>缺點
</strong>集中式的檔案控制系統對控制系統的設計來說, 當然是比較簡單的, 因為所有和版本控制有關的重要資訊, 幾乎都可以集中在系統上控管, 不過, 它在本質上也具備一些缺點.</p>
<p>首先, 由於檔案庫是集中控管, 因此幾乎都是在透過網路可連結的主機之上, 開發者想要自檔案庫中取得資訊或檔案、想要將檔案提交至檔案庫, 或是對檔案庫做一些其他的操作, 都必須在能夠連網的環境下進行.
這會影響版本控制系統為開發者提供支援及協助的時間. 例如, 你已經在本地端做好了必要的修改, 想要提交到系統上, 卻因為正處於無法連網的環境, 所以無法將檔案提交出去.
當然, 或許你會想, 可以等到能聯網之後才提交就好了, 但是, 版本控制中, 我們希望每次提交的變更都是一個不可分割的最小單位, 若因無法連網, 無法將已完成的修改提交出去, 那麼也就無法繼續修改其他的項目, 因為這將會使得, 應該被分為多次提交的內容混在一塊了.</p>
<p>再者, 由於每個開發者的修改, 時常是反覆持續進行, 即使都在處理同一問題, 也有可能未到穩定、完備到足以提供其他開發者使用的程度, 若是在修改的過程中即提交至集中的檔案庫上, 那麼, 便有可能讓集中檔案庫中的檔案, 處於不穩定、不成熟的狀態. 當然, 也可以讓開發者持續修改至足夠穩定完備後, 再將修改內容提交至檔案庫, 但是, 在這個空窗期裡, 開發者就無法得到版本控制系統的支援, 他沒有辦法將修改過程中的不同階段, 畫分成為多個版本, 使得他仍然可以從版本控制系統中得到好處.</p>
<hr />
<h1 id="_2">分布式版本控制</h1>
<p>基於集中式版本控制的缺點, 分布式的版本控制系統開始興起, 並且普及流行.</p>
<p>分布式版本控制系统本身是根本没有“中央服务器”這個概念的, <strong>每个人的电脑上都是一个完整的版本库</strong>, 这样, 你工作的时候, 就不需要联网了, 因为版本库就在你自己的电脑上, 任何修改都能<strong>隨時提交</strong>.</p>
<p>既然每个人电脑上都有一个完整的版本库, 那多个人如何协作呢?
比方说你在自己电脑上改了文件A, 你的同事也在他的电脑上改了文件A, 这时, 你们俩之间只需把各自的修改推送给对方, 就可以互相看到对方的修改了.</p>
<p>但是假如今天你的同事病了, 他的电脑压根没有开机, 又或者你們一個白班一個夜班, 那這樣, 你們的兩台電腦是互相訪問不了的, 這樣怎麼推送各自的修改呢? 所以, 分布式版本控制系统中通常也是有一台充当“中央服务器”的电脑, 但这个服务器的作用仅仅是用来方便“交换”大家的修改, 没有它大家也一样干活, 只是交换修改不方便而已.</p>
<p><strong>所以, 對分散式版本控制系統來說, 精神不在於維持不同開發者間的同步, 而是讓每個開發者擁各自獨立的變更集合, 開發者之間可分享自己的變更集合.
</strong>在分散式的版本控制系統下, 開發者可以進行推（push）的動作, 其意義即將自身檔案庫中的變更（在其他檔案庫擁有者的授權之下）送至其他的檔案庫, 也可以進行拉（pull）的動作.</p>
<p>因為分散式版本控制系統本質的關係, 使得此類系統更重視對分支（branch）的支持, 它們通常有較好的分支及合併的能力.
也正因為這樣, 所以衍生出多種工作流程, 像是<strong>集中式</strong>（Centralized）、<strong>整合管理者式</strong>（Integration-Manager）、<strong>司令官及副官</strong>（Dictator and Lieutenants）等等.</p>
<p>集中式就是所有的人共用檔案庫, 都能夠隨意的存取檔案庫;</p>
<p>整合管理式的工作流程下, 僅有少數的整合管理者, 被授權對檔案庫做推的動作, 其他的開發者僅能利用請求拉（request pull）, 請求整合管理者將其所做修改納入.</p>
<p>大規模的項目則可採所謂司令官及副官（Dictator and Lieutenants）的工作流程, 在此流程下, 唯一的一名司令官將系統畫分為多個子系統, 分別授權予個別的副官, 去管理各子系統的變更集合, 而司令官則為最上層的整合者, 有權利決定從這些副官的所做的變更拉至中心檔案庫, 接著再推至blessed檔案庫, 以供其他人開發者由此進行複製的動作.</p>
    </div>

        </div>
        <div id="footer">
              <p>
                Copyright © 2012-2016 <a href="http://www.samllcpp.com/" target="_blank">Martin</a> Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
              </p>
        </div>
    </body>
</html>