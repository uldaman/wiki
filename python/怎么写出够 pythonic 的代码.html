<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/static/css/typo.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/reset_typo.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
        <link rel="shortcut icon" href="/static/images/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/static/images/favicon.ico" type="image/x-icon">
        <title>怎么写出够 pythonic 的代码 - Wiki | Small Cpp</title>
        <meta name="keywords" content=""/>
        <meta name="description" content=""/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="container" class="typo">
            
    <div id="header">
        <div id="post-nav">
            
            <a href="/">Home</a> » <a href="/#python">python</a> » 怎么写出够 pythonic 的代码
            
        </div>
    </div>
    <div class="clearfix"></div>
    <div id="content">
        <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#references">References:<br></a></li>
<li><a href="#_1">列表生成式</a></li>
<li><a href="#_2">生成器表达式</a></li>
<li><a href="#sorted">sorted( )</a></li>
<li><a href="#map">map( )</a></li>
<li><a href="#reduce">reduce( )</a></li>
<li><a href="#filter">filter( )</a></li>
<li><a href="#lambda">lambda 表达式</a></li>
<li><a href="#_3">切片</a></li>
<li><a href="#_4">用正确的数据结构</a></li>
<li><a href="#_5">字符串的优化</a></li>
</ul>
</div>
<p>因为我也是从 C++ 转向 Python 的, 所以总感觉自己在用写 C++ 代码的思维写 Python, 没有真正用到其作为脚本语言的优势, 很像披着 Python 外衣的 C++ 代码.</p>
<p>所以才有了这篇 wiki, 相当于对之前学过的知识做个小结, 并且收集一些 Pythonic 的代码.</p>
<blockquote>
<p>注意, 部分内容收集自互联网;<br>
另外推荐本书: <a href="https://yunpan.cn/c6mPavfeDzHYK">&lt;&lt;编写高质量代码 - 改善 Python 程序的 91 个建议&gt;&gt;</a>  <strong>访问密码</strong> 9f75</p>
</blockquote>
<h1 id="references">References:<br></h1>
<p><a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python.md">python 性能调优</a><br>
<a href="http://wuzhiwei.net/be_pythonic/">让你的Python代码更加pythonic</a><br>
<a href="http://gold.xitu.io/entry/56010de260b27db45a4f845f">关于 Python 的最全面试题</a></p>
<h1 id="_1">列表生成式</h1>
<p>提供一个可迭代的对象生成一个新列表</p>
<p><code>[exp for iter_var in iterable]</code></p>
<p><code>[exp for iter_var in iterable if cond_exp]</code></p>
<p>首先迭代 iterable 里所有内容, 每一次迭代, 都把 iterable 里相应内容放到 iter_var 中, 再在表达式 exp 中应用该 iter_var 的内容, 最后用表达式的计算值生成一个新的列表.</p>
<p>例如, 把一个 list 中所有的字符串变成小写:</p>
<div class="hlcode"><pre><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Hello&#39;</span><span class="p">,</span> <span class="s">&#39;World&#39;</span><span class="p">,</span> <span class="s">&#39;IBM&#39;</span><span class="p">,</span> <span class="s">&#39;Apple&#39;</span><span class="p">]</span>
<span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">L</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="s">&#39;hello&#39;</span><span class="p">,</span> <span class="s">&#39;world&#39;</span><span class="p">,</span> <span class="s">&#39;ibm&#39;</span><span class="p">,</span> <span class="s">&#39;apple&#39;</span><span class="p">]</span>
</pre></div>


<p><br>
参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-lie-biao-sheng-cheng-shi.html">Python 高级特性之列表生成式</a></p>
<h1 id="_2">生成器表达式</h1>
<p>当列表过长, 而我们也不需要一次性获取全部数据时, 应当考虑使用生成器(generator)表达式而不是列表解析;</p>
<p>生成器表达式的语法和列表解析一样, 只不过生成器表达式是被（）括起来的, 而不是 [ ], 如下:</p>
<p><code>(exp for iter_var in iterable)</code></p>
<p><code>(exp for iter_var in iterable if cond_exp)</code></p>
<p>生成器表达式使用了 "惰性计算" (lazy evaluation, 也有翻译为 "延迟求值", 我以为这种按需调用 call by need 的方式翻译为惰性更好一些), 只有在检索时才被赋值 (evaluated), 所以在列表比较长的情况下使用更有效 (节省内存).</p>
<p>参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-sheng-cheng-qi-biao-da-shi.html">Python 高级特性之生成器表达式</a></p>
<h1 id="sorted">sorted( )</h1>
<p>sorted 语法如下:</p>
<p><code>sorted(iterable, cmp = None, key = None, reverse = False)</code></p>
<ul>
<li>iterable: 是可迭代类型</li>
<li>cmp: 定制一个接收两个参数比较函数, 比较什么由下一个参数 key 决定</li>
<li>key: 指定一个接收一个参数的函数, 这个函数用于从序列的每个元素中提取一个用于排序的依据</li>
<li>reverse: 排序规则. reverse = True 或者 reverse = False</li>
<li>返回值: 是一个经过排序的可迭代类型, 与 iterable 一样</li>
</ul>
<blockquote>
<p>一般来说, cmp 和 key 可以使用 lambda 表达式</p>
</blockquote>
<p>正序:</p>
<div class="hlcode"><pre><span class="nb">sorted</span><span class="p">([</span><span class="mi">36</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">21</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">36</span><span class="p">]</span>
</pre></div>


<p><br>
倒序:</p>
<div class="hlcode"><pre><span class="nb">sorted</span><span class="p">([</span><span class="mi">36</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">21</span><span class="p">],</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span><span class="p">[</span><span class="mi">36</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</pre></div>


<p><br>
如果想自己实现倒序排序, 则可以自己写 <strong>cmp</strong> 函数, 然后做为 sorted() 的第二个参数.</p>
<p>通常规定, 对于两个元素 x 和 y:</p>
<ul>
<li>如果认为 x &lt; y, 则返回 -1</li>
<li>如果认为 x == y, 则返回 0</li>
<li>如果认为 x &gt; y, 则返回 1</li>
</ul>
<p>我们来实现倒序:</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">reversed_cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>


<p><br>
传入自定义的比较函数 reversed_cmp, 就可以实现倒序排序:</p>
<div class="hlcode"><pre><span class="nb">sorted</span><span class="p">([</span><span class="mi">36</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">21</span><span class="p">],</span> <span class="n">reversed_cmp</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span><span class="p">[</span><span class="mi">36</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</pre></div>


<p><br>
再来看年 sorted() 的 <strong>key</strong> 参数:</p>
<div class="hlcode"><pre><span class="n">L</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="k">print</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span><span class="p">[(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
</pre></div>


<p><br>
L 中的元素是一个 tupe, key 参数指定用 <code>tupe[1]</code> 做为依据来比较</p>
<p>参考链接:<br>
<a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-sorted.html">Python 高级特性之 sorted( )</a><br>
<a href="http://www.cnblogs.com/woshitianma/p/3222989.html">Python中sorted()方法的用法</a></p>
<h1 id="map">map( )</h1>
<p>map() 函数接收两个参数, 一个是函数, 一个是序列, map() 将传入的函数依次作用到序列的每个元素, 并把结果作为新的 list 返回.</p>
<p>例子, 求 1 到 10 每个数的乘阶:</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="nb">map</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
</pre></div>


<p><br>
参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-map.html">Python 高级特性之 map( )</a></p>
<h1 id="reduce">reduce( )</h1>
<p>reduce() 函数接收两个参数, 一个是函数, 一个是序列;</p>
<p>但传入的这个函数必须接收两个参数, reduce() 会把这个函数运算的结果继续和序列的下一个元素做<strong>累积</strong>运算, 相当于:</p>
<div class="hlcode"><pre><span class="nb">reduce</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">])</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">x3</span><span class="p">),</span> <span class="n">x4</span><span class="p">)</span>
</pre></div>


<p><br>
例子, 对序列求和:</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="nb">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span><span class="mi">25</span>
</pre></div>


<p><br>
参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-reduce.html">Python 高级特性之 reduce( )</a></p>
<h1 id="filter">filter( )</h1>
<p>filter() 函数接收两个参数, 一个是函数, 一个是序列;</p>
<p>filter() 把传入的函数依次作用于每个元素, 然后根据返回值是 True 还是 False 决定保留还是丢弃该元素.</p>
<p>例如, 在一个 list 中, 删掉偶数, 只保留奇数, 可以这么写:</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">is_odd</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

<span class="nb">filter</span><span class="p">(</span><span class="n">is_odd</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</pre></div>


<p><br>
参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-filter.html">Python 高级特性之 filter( )</a></p>
<h1 id="lambda">lambda 表达式</h1>
<p>当我们在传入函数时, 有些时候, 不需要显式地定义函数, 直接传入匿名函数更方便, 匿名函数也叫 lambda 表达式.</p>
<p>lambda 因为是一个表达式, 所以不要写 return, 返回值就是该表达式的结果.</p>
<p>lambda 语法中, 冒号前是参数, 多个用逗号隔开, 冒号右边的返回值.</p>
<p><code>lambda x: x * x</code> 实际上就是:</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</pre></div>


<p><br>
用 lambda 表达式还有个好处, 因为函数没有名字, 不必担心函数名冲突, 此外, lambda 表达式也是一个函数对象, 也可以把 lambda 表达式赋值给一个变量, 再利用变量来调用该函数.</p>
<div class="hlcode"><pre><span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="c"># x 的平方</span>
<span class="n">v</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="n">y</span> <span class="c"># x 的 y 次方</span>
</pre></div>


<p><br>
例子, 求 1 到 100 的合:</p>
<div class="hlcode"><pre><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span><span class="mi">5050</span>
</pre></div>


<p><br>
lambda 可以配合 map、reduce、filter、sorted 高效操作列表.</p>
<p>参考链接: <a href="http://www.smallcpp.com/python-gao-ji-te-xing-zhi-lambda.html">Python 高级特性之 lambda</a></p>
<h1 id="_3">切片</h1>
<p>对于具有序列结构的数据来说, 切片操作的语法是:</p>
<p><code>consequence[start_index : end_index : step]</code></p>
<p><code>注意</code>: 对于序列结构数据来说, <strong>xxx_index</strong>和<strong>step</strong>都具有正负两个值, 分别表示左右两个方向取值.</p>
<ul>
<li>start_index: 表示切片的起始位置 (<strong>包含</strong>该位置的元素)<ul>
<li>默认为序列第一个元素, 用正索引表示为 0</li>
<li>默认为序列第一个元素, 用负索引表示为 <code>-len(consequence)</code></li>
</ul>
</li>
<li>end_index: 表示切片的结束位置 (<strong>不包含</strong>该位置的元素)<ul>
<li>默认为序列最后一个元素, 用正索引表示为 <code>len(consequence) - 1</code></li>
<li>默认为序列最后一个元素, 用负索引表示为 -1</li>
</ul>
</li>
<li>step: 表示取值的步长, 默认为 1, 步长值不能为 0<ul>
<li>正数表示向正向递增取值</li>
<li>负数表示向反向递增取值</li>
</ul>
</li>
</ul>
<p><strong>xxx_index</strong>和<strong>step</strong>并不是必须的, 可以有下面这些组合:</p>
<ul>
<li><code>con[start_index]</code>: 返回索引值为 start_index 的对象, start_index 为 -len(con) 到 len(con) - 1 之间任意整数</li>
<li><code>con[start_index : end_index]</code>: 返回索引值为 start_index 到 end_index - 1 之间的连续对象</li>
<li><code>con[start_index : end_index : step]</code>: 从 start_index 开始, 每递增 step 位取个值, 到 end_index - 1 结束</li>
<li><code>con[start_index:]</code>: 缺省 end_index, 表示从 start_index 开始到序列中最后一个对象</li>
<li><code>con[:end_index］</code>: 缺省 start_index, 表示从序列中第一个对象到 end_index - 1 之间的片段</li>
<li><code>con[:]</code>: 缺省 start_index 和 end_index, 表示从第一个对象到最后一个对象的完整片段</li>
<li><code>con[::step]</code>: 缺省 start_index 和 end_index, 表示对序列按 step 正向/反向取值</li>
</ul>
<p>例子, 返转字符串</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">reverse_str</span><span class="p">(</span> <span class="n">s</span> <span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>


<p><br>
字符串也是一种序列, 因此利用切片就能极方便地反转字符了, 步长为 -1 即反向、每次递增 1 地从序列中取值.</p>
<h1 id="_4">用正确的数据结构</h1>
<p><strong>字典 (dictionary) 与列表 (list)</strong>:<br>
Python 字典中使用了 hash table, 因此查找操作的复杂度为 O(1), 而 list 实际是个数组, 在 list 中, 查找需要遍历整个 list, 其复杂度为 O(n), 因此对成员的查找访问等操作字典要比 list 更快.</p>
<p><strong>集合 (set) 与列表 (list)</strong>:<br>
set 的 union、ntersection、difference 操作要比 list 的迭代要快, 因此如果涉及到求 list 交集, 并集或者差的问题可以转换为 set 来操作.</p>
<ul>
<li>set(list1) | set(list2)：包含 list1 和 list2 所有数据的新集合</li>
<li>set(list1) &amp; set(list2)：包含 list1 和 list2 中共同元素的新集合</li>
<li>set(list1) - set(list2)：在 list1 中出现但不在 list2 中出现的元素的集合</li>
</ul>
<h1 id="_5">字符串的优化</h1>
<p>python 中的字符串对象是不可改变的，因此对任何字符串的操作如拼接，修改等都将产生一个新的字符串对象，而不是基于原字符串，因此这种持续的 copy 会在一定程度上影响 python 的性能.</p>
<p><code>使用 join 而不是 + 连接字符串</code></p>
<p>避免类似下面的代码片段:</p>
<div class="hlcode"><pre><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">somelist</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">x</span>
</pre></div>


<p><br>
而是要使用下面这种:</p>
<div class="hlcode"><pre><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">somelist</span><span class="p">)</span>
</pre></div>


<p><br>
当对字符串可以使用<strong>正则表达式</strong>或者内置函数来处理的时候，选择内置函数, 如 str.isalpha()、str.isdigit()、str.startswith(('x', 'yz'))、str.endswith(('x', 'yz')) 等.</p>
<p>对字符进行格式化比直接串联读取要快，因此要使用:<br>
<code>out = '&lt;html&gt;%s%s%s%s&lt;/html&gt;'' % (head, prologue, query, tail)</code><br>
而不是:<br>
<code>out = '&lt;html&gt;'' + head + prologue + query + tail + '&lt;/html&gt;'</code></p>
    </div>

    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="怎么写出够 pythonic 的代码" data-title="怎么写出够 pythonic 的代码" data-url="http://wiki.smallcpp.com/python/怎么写出够 pythonic 的代码.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"smallwiki"};
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->


        </div>
        <div id="footer">
              <p>
                Copyright © 2012-2016 <a href="http://www.samllcpp.com/" target="_blank">Martin</a> Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
              </p>
        </div>
    </body>
</html>